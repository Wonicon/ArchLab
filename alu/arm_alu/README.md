### 功能表

| ALU_op[3:0] | 助记符 | 操作       | 结果               | 是否更新标志 |
|-------------|--------|------------|--------------------|--------------|
| 0000        | AND    | 按位与     | Rd← Rn AND Rs      | S=1          |
| 0001        | EOR    | 按位异或   | Rd← Rn EOR Rs      | S=1          |
| 0010        | SUB    | 减         | Rd← Rn - Rs        | S=1          |
| 0011        | RSB    | 反向减     | Rd← Rs - Rn        | S=1          |
| 0100        | ADD    | 加         | Rd← Rn + Rs        | S=1          |
| 0101        | ADC    | 带进位加   | Rd← Rn + Rs        | S=1          |
| 0110        | SBC    | 带进位减   | Rd← Rn - Rs - !Cin | S=1          |
| 0111        | RSC    | 带进位反减 | Rd← Rs - Rn - !Cin | S=1          |
| 1000        | TST    | 测试       | Rn AND Rs          | 强制         |
| 1001        | TEQ    | 测试相等   | Rn EOR Rs          | 强制         |
| 1010        | CMP    | 比较       | Rn - Rs            | 强制         |
| 1011        | CMN    | 比较反值   | Rn + Rs            | 强制         |
| 1100        | ORR    | 按位或     | Rd← Rn OR Rs       | S=1          |
| 1101        | MOV    | 传送       | Rd← Rs             | S=1          |
| 1110        | BIC    | 清零       | Rd← Rn AND ~Rs     | S=1          |
| 1111        | MVN    | 求反       | Rd← ~Rs            | S=1          |

### 设计思路

[MIPS的思路](https://github.com/Wonicon/ArchLab2015/tree/master/lab_03_alu/mips_alu)是按照功能去划分。
这里则是尽可能按照对输入的处理进行划分。类似于二级译码的处理手段主要处理对偶的功能，尤其是像加减、01这种。
然而ARM中算术指令要多一些，如果加减分为一组的话，反向减和带进位加减和带进位反向减就不太好分组了。

反向减法可以由正向减法结果取负得到，但是取负意味着要+1，就不可必满地要增加一个加法器了。
所以，我认为不应该从加法器的输出，而应该从加法器的输入着手，即关注内部加法器的三个输入各自在不同的ALU_op下取什么值。

对Rn来说，`0010` `0100` `0101` `0110` `1010` `1011`情况下为正数；`0011` `0111`情况下为负数；
其它情况做非算术运算，可以不关心送入加法器的具体是什么值（是这样吗？）。
据此得到一个一位输出的逻辑函数，作为Rn与Rn非的二路选择器的选择子。

必须为正数的逻辑表达式是`0x10 + 010x + 101x`，必须为负数的逻辑表达式是`0x11`，
剩下的逻辑运算的OP有`0000` `0001` `1000` `1001` `1100` `1101` `1110` `1111`，可以考虑用这些项来服务正数判断和负数判断的逻辑函数的化简。

`1000 + 1001 + 1100 + 1101 + 1110 + 1111 + 101x`可以化简为`1xxx`，`0000 + 0001 + 010x`可以化简为`0x0x`，
所以只要ALU_op[3]为1就可以肯定Rn为正数，完整的逻辑函数为`0x10 + 0x0x + 1xxx`，覆盖了2 + 4 + 8 = 14个最小项；
这意味着可以使用判断负数的逻辑函数，这样既做到了选择子函数简单，也保证了互斥。

对Rs来说，`0010` `0110` `1010`情况下为负数，`0011` `0100` `0101` `0111` `1011`情况下为正数。同样据此对Rs和Rs非做二路选择。
剩下的逻辑运算的OP有`0000` `0001` `1000` `1001` `1100` `1101` `1110` `1111`。

一开始为负的判断是`0x10 + 1010`，而为正的函数是`0x11 + 010x + 1011`。判负的函数增加`1110`可以得到`1x10`，
进一步化简成`xx10`，这已经足够简单了，剩下的都交给判正函数即可。

得到了判定符号的函数，下面就是取反了。实验手册上对MIPS的处理是用32位的按位异或，我觉得电路层数太多了。
如果使用二路选择器，应该能简单一些，因为选择器的电路复杂度主要和选择子的位数有关。总线再宽，也只是增加同一级的小选择器的数量，
不会增加电路的层数。

这样一来，完成取负操作的任务如ALU经典的处理手段一样，落到了加法器的进位输入上。不过这里的情况依然比较复杂。
首先ARM的ALU本身是支持进位输入的，这样就不能把内部加法器的进位输入的语义完全替换成减法指示。
其次ARM的ALU甚至可以在取负的同时再算上进位，两种语义混合在一起！
不过在减法过程中的进位输入和减法指示可以相互作用，最后送入加法器的进位只和ALU进位输入相关，具体地：

在带进位减的情况下，只有一个操作数取负，那么需要一个进位1来完成取反加一的操作，此时减去进位标志的非，
即若进位标志为1，则减去0，加法器的进位依然为1，反之则为0；在带进位反减的情况下，依然只有一个操作数取负，同样需要一个
进位1来完成取反加一的操作，此时减去进位标志也是同样的情况。可见，这里加法器的进位实际上与进位标志完全是相关的，
而且什么逻辑门都不需要，这个情况可以和带进位加合并在一起。

所以需要为这些情况进行选择：

1. `0010` `0011` `1010` 进位为1
2. `0100` `1011` 进位为0
3. `0101` `0110` `0111` 进位为ALU的进位标志
4. 其它情况并不关心加法器进位的行为

~~我觉得带进位减法完全是发现刚好可以塞这么一个功能，本着少一件不如多一件的原则设计出来的，你真的是RISC吗，bro？~~

经过这三个逻辑电路和选择器后，就得到了处理之后的3个加法器的输入。
至于符号位，overflow根据处理后的加数和最后的输出进行判断应该没有问题。
在减法语义下，内部加法器的carry_out为1是没有借位，看样子需要针对`是否进行了减法`进行判断。
我们已经有了两个判断取负的逻辑函数，只要把它们的结果或起来就可以判断是否进行了减法。真庆幸没有全取负加法！
negative和zero这种应该是和ALU_out相关而不是和内部加法器的结果相关。因为逻辑操作也可以影响标志位。

**查看ARM手册，了解每个操作具体影响哪些标志位！**

| 指令        | 标志位说明                                           |
|-------------|------------------------------------------------------|
| SUB,SBC,RSB | N=Rd[31], Z=(Rd==0), C=**Not**BorrowFrom, V=OverflowFrom |
| ADD,ADC     | N=Rd[31], Z=(Rd==0), C=CarryFrom, V=OverflowFrom         |
| AND, ORR | N=Rd[31], Z=(Rd==0), C=shift_carry_out/cin, V=unaffected

| 指令 | N        | Z         | C                 | V              |
|------|----------|-----------|-------------------|----------------|
| ADC  | N=Rd[31] | Z=(Rd==0) | C=CarryFrom       | V=OverflowFrom |
| ADD  | N=Rd[31] | Z=(Rd==0) | C=CarryFrom       | V=OverflowFrom |
| AND  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| BIC  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| CMN  | N=Rd[31] | Z=(Rd==0) | C=NotCarryFrom    | V=OverflowFrom |
| CMP  | N=Rd[31] | Z=(Rd==0) | C=NotCarryFrom    | V=OverflowFrom |
| EOR  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| MOV  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| MVN  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| ORR  | N=Rd[31] | Z=(Rd==0) | C=shift_carry_out | V=unaffected   |
| RSB  | N=Rd[31] | Z=(Rd==0) | C=NotCarryFrom    | V=OverflowFrom |
| RSC  | N=Rd[31] | Z=(Rd==0) | C=NotCarryFrom    | V=OverflowFrom |


逻辑操作方面也可以做一些合并。首先输出结果写不写到寄存器和标志输出写不写到CPSR上应该由外部的控制器决定。
由于ALU可以为一个指令（比如乘法）使用多次，那么由ALU来维护状态我感觉是不必要的。
我认为有些场合是需要控制器连续使用ALU并且只有最后结果是有意义的（比如乘除法），
也许控制器优先处理ALU_out，之后再慢慢判断标志位的取舍，这时候ALU已经可以进入到下一阶段的运算中了。
根据以上一些想法（~~臆测~~），我认为在逻辑等运算中，可以无视加法器的行为（我需要利用这个条件来化简加法器的电路），
而且写入寄存器和不写入寄存器的同功能操作完全可以合并（然而这些合并并没有给化简带来多少帮助）。

除此之外，BIC和MVN可以进行合并，因为MVN相比BIC只是少了与Rn的操作，可以认为MVN进行了**无意义的与操作**，
即BIC的Rn被全1屏蔽掉了（按位或1），刚好这两个操作的OP只相差一位，合并起来非常方便。
然而，基于值而不是选择器的合并，我也只找到了这么一个情况，用取负使能按位异或来取反也算是用值来合并，
但是我感觉在宽总线的情况下还是选择器优势更大些。

### 其它

目前实验实现值得商榷的地方就是非算术运算时是否要控制加法器的行为。
