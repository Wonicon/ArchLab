### 功能表

| ALU_op[3:0] | 助记符 | 操作       | 结果               | 是否更新标志 |
|-------------|--------|------------|--------------------|--------------|
| 0000        | AND    | 按位与     | Rd← Rn AND Rs      | S=1          |
| 0001        | EOR    | 按位异或   | Rd← Rn EOR Rs      | S=1          |
| 0010        | SUB    | 减         | Rd← Rn - Rs        | S=1          |
| 0011        | RSB    | 反向减     | Rd← Rs - Rn        | S=1          |
| 0100        | ADD    | 加         | Rd← Rn + Rs        | S=1          |
| 0101        | ADC    | 带进位加   | Rd← Rn + Rs        | S=1          |
| 0110        | SBC    | 带进位减   | Rd← Rn - Rs - !Cin | S=1          |
| 0111        | RSC    | 带进位反减 | Rd← Rs - Rn - !Cin | S=1          |
| 1000        | TST    | 测试       | Rn AND Rs          | 强制         |
| 1001        | TEQ    | 测试相等   | Rn EOR Rs          | 强制         |
| 1010        | CMP    | 比较       | Rn - Rs            | 强制         |
| 1011        | CMN    | 比较反值   | Rn + Rs            | 强制         |
| 1100        | ORR    | 按位或     | Rd← Rn OR Rs       | S=1          |
| 1101        | MOV    | 传送       | Rd← Rs             | S=1          |
| 1110        | BIC    | 清零       | Rd← Rn AND ~Rs     | S=1          |
| 1111        | MVN    | 求反       | Rd← ~Rs            | S=1          |

### 设计思路

[MIPS的思路](https://github.com/Wonicon/ArchLab2015/tree/master/lab_03_alu/mips_alu)是按照功能去划分。
这里则是尽可能按照对输入的处理进行划分。类似于二级译码的处理手段主要处理对偶的功能，尤其是像加减、01这种。
然而ARM中算术指令要多一些，如果加减分为一组的话，反向减和带进位加减和带进位反向减就不太好分组了。

反向减法可以由正向减法结果取负得到，但是取负意味着要+1，就不可必满地要增加一个加法器了。
所以，我认为不应该从加法器的输出，而应该从加法器的输入着手，即关注三个输入各自在不同的ALU_op下取什么值。

对Rn来说，`0010` `0100` `0101` `0110` `1010` `1011`情况下为正数；`0011` `0111`情况下为负数；
其它情况做非算术运算，可以不关心送入加法器的具体是什么值（是这样吗？）。
据此得到一个一位输出的逻辑函数，作为Rn与Rn非的二路选择器的选择子。

对Rs来说，`0010` `0110` `1010`情况下为负数，`0011` `0100` `0101` `0111` `1011`情况下为正数。同样据此对Rs和Rs非做二路选择。

这样一来，完成取负操作的任务如ALU经典的处理手段一样，落到了加法器的进位输入上。不过这里的情况依然比较复杂。
首先ARM的ALU本身是支持进位输入的，这样就不能把内部加法器的进位输入的语义完全替换成减法指示。
其次ARM的ALU甚至可以在取负的同时再处理进位，两种语义混合在一起！
不过在减法过程中的进位输入和减法指示可以相互作用，最后送入加法器的进位只和ALU进位输入相关。
但是我们仍然需要为这些情况进行选择：

1. `0010` `0011` `1010` 进位为1
2. `0100` `1011` 进位为0
3. `0101` `0110` `0111` 进位为ALU的进位输入
4. 其它情况并不关心加法器的行为

~~我觉得带进位减法完全是发现刚好可以塞这么一个功能，本着少一件不如多一件的原则设计出来的，你真的是RISC吗，bro？~~

经过这三个逻辑电路和选择器后，就得到了处理之后的3个加法器的输入。至于符号位，overflow根据处理后的加数和最后的输出进行判断应该没有问题。在减法语义下，内部加法器的carry_out为1是没有借位，看样子需要针对`是否进行了减法`进行判断。
negative和zero这种应该是和ALU_out相关而不是和内部加法器的结果相关。因为逻辑操作也可以影响标志位。

**查看ARM手册，了解每个操作具体影响哪些标志位！**

逻辑操作方面也可以做一些合并。首先输出结果写不写到寄存器和标志输出写不写到CPSR上应该由外部的控制器决定。
由于ALU可以为一个指令（比如乘法）使用多次，那么由ALU来维护状态我感觉是不必要的。
也许控制器优先处理ALU_out，之后再慢慢判断标志位的取舍，这时候ALU已经可以进入到下一阶段的运算中了。
根据以上一些想法（臆测），我认为在逻辑等运算中，可以无视加法器的行为，
而且写入寄存器和不写入寄存器的同功能操作完全可以合并（然而这些合并并没有给化简带来多少帮助）。

除此之外，BIC和MVN可以进行合并，因为MVN相比BIC只是少了与Rn的操作，可以认为MVN进行了无意义的与操作，即BIC的Rn被全1屏蔽掉了（按位或1），刚好这两个操作的OP只相差一位，合并起来非常方便。然而，基于值而不是选择器的合并，我也之找到了这么一个情况。

### 关于第二个操作数

实验讲义上称其作移位操作数，我擅自称其为Rs，这个操作数可以级联移位器。以下是手册上的表述：

```
Of the two source operands, one is always a register. The other is called a shifter operand and is either an immediate value or a register.
If the second operand is a register value, it can have a shift applied to it.
```

### 其它

目前实验实现值得商榷的地方就是非算术运算时是否要控制加法器的行为。
