| ALU_op[3:0] | ALU_ctr[2:0] | 功能             |
|-------------|--------------|------------------|
| 0000        | 111          | 加法(不产生溢出) |
| 0001        | 111          | 减法(不产生溢出) |
| 0010        | 000          | 前导0            |
| 0011        | 000          | 前导1            |
| 0100        | 100          | 加法(不产生溢出) |
| 0101        | 101          | slt/slti         |
| 0110        | 010          | 或               |
| 0111        | 101          | sltu/sltiu       |
| 1000        | 011          | 或非             |
| 1001        | 001          | 异或             |
| 1010        | 110          | seb              |
| 1011        | 110          | seh              |
| 1110        | 111          | 加法(可产生溢出) |
| 1111        | 111          | 减法(可产生溢出) |

### 思路解读

MIPS中很多操作都是对偶的存在，也就是说，可以利用指令的一部分做大范围的功能选择，另一部分做小范围的功能选择。
从表中可以看出，小范围的功能选择主要都是依赖ALU_op[0]来实现。但是并不是每个功能都是成双成对地出现，并且公共位的位置都一样的，
所以需要进行二级译码，保证最后以大范围的功能为单位进行输出选择。通过这种做法，可以只使用一个加法器就完成功能多样的基本算术运算。
此外，可以直接以ALU_op[0]的值作为输出来实现功能，而不是两个功能都用电路实现，最后靠ALU_op[0]选择输出。这样可以节省电路器件的开销。
不过转化可能会带来更大的延迟，不如二选一那么直接方便。

### 前导零算法
