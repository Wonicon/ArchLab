### 功能表

| ALU_op[3:0] | ALU_ctr[2:0] | 功能             |
|-------------|--------------|------------------|
| 0000        | 111          | 加法(不产生溢出) |
| 0001        | 111          | 减法(不产生溢出) |
| 0010        | 000          | 前导0            |
| 0011        | 000          | 前导1            |
| 0100        | 100          | 加法(不产生溢出) |
| 0101        | 101          | slt/slti         |
| 0110        | 010          | 或               |
| 0111        | 101          | sltu/sltiu       |
| 1000        | 011          | 或非             |
| 1001        | 001          | 异或             |
| 1010        | 110          | seb              |
| 1011        | 110          | seh              |
| 1110        | 111          | 加法(可产生溢出) |
| 1111        | 111          | 减法(可产生溢出) |

### 思路解读

MIPS中很多操作都是对偶的存在，也就是说，可以利用指令的一部分做大范围的功能选择，另一部分做小范围的功能选择。

从表中可以看出，小范围的功能选择主要都是依赖ALU_op[0]来实现。但是并不是每个功能都是成双成对地出现，并且公共位的位置都一样的，所以需要进行二级译码，保证最后以大范围的功能为单位进行输出选择。通过这种做法，可以只使用一个加法器就完成功能多样的基本算术运算。

此外，可以直接以ALU_op[0]的值作为输出来实现功能，而不是两个功能都用电路实现，最后靠ALU_op[0]选择输出。这样可以节省电路器件的开销。不过转化可能会带来更大的延迟，不如二选一那么直接方便。

### 前导零算法

在stackoverflow上，有关于前导0的讨论，优秀的方法是二分查找。
而写法上最为简洁的有[这个](http://stackoverflow.com/a/2376530)：
```verilog
result[4] = (value[31:16] == 16'b0);
val16     = result[4] ? value[15:0] : value[31:16];
result[3] = (val16[15:8] == 8'b0);
val8      = result[3] ? val16[7:0] : val16[15:8];
result[2] = (val8[7:4] == 4'b0);
val4      = result[2] ? val8[3:0] : val8[7:4];
result[1] = (val4[3:2] == 2'b0);
result[0] = result[1] ? ~val4[1] : ~val4[3];
```
但是这样的写法没有考虑全32位全是0的情况。但是这只需要多加一级电路做判断就可以了。
而大入扇的或门，其层数最多也就是log2(width)次，跟二分查找的层数大致相同，可以并行处理，并没有大影响。

不过我一开始做的时候使用的是[这个方案](http://stackoverflow.com/a/23857066):
```c
int n = 32;
unsigned y;

y = x >>16; if (y != 0) { n = n -16; x = y; }
y = x >> 8; if (y != 0) { n = n - 8; x = y; }
y = x >> 4; if (y != 0) { n = n - 4; x = y; }
y = x >> 2; if (y != 0) { n = n - 2; x = y; }
y = x >> 1; if (y != 0) return n - 2;
return n - x;
```
这是C代码，但是可读性看上去更高一点。我用Verilog实现了这段代码，结果不可避免的产生了减法器和移位器。
感受一下，在ALU里为了算前导零而有若干个减法器。

我考虑过按位与的方式来优化，因为减数都是2的幂。但是这行不通。因为n从一开始就是32，这导致了每一次减法都会产生借位！

几经折腾，我把初始值从32改成了0，减法变成了按位与（即做加法），移位变成了位截取和位拼接。不变的大概就只剩下那难看的generate语句和勉强为之的线网变量了。

### 其他

进位输出一直是比较头疼的事情，因为本身的定义比较语义化，但是从最底层处理简单，从抽象了加法操作的层面实现起来就感到很困难。
这里采用了作弊的方法，即：
```verilog
assign {carry_out, out} = A + B + carry_in;
```
这样实际上是在做33位加法，跟用`long long`实现64位乘法，用Java、Python等实现大数运算一样，~~做了等于没做~~。

个别指令含义：

|指令 |含义                               |
|-----|-----------------------------------|
|slt  |set on less than                   |
|slti |set on less than immediate         |
|sltu |set on less than unsigned          |
|sltiu|set on less than immediate unsigned|
|seb  |sign extend byte                   |
|seh  |sign extend halfword               |
